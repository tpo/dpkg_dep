#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# (c) 2015, Tomas Pospisek <tpo_deb@sourcepole.ch>
#
# Docu used to implement this:
#
#   how to create a Debian package:
#   * http://ptspts.blogspot.ch/2010/02/how-to-create-debianubuntu-package-deb.html
#
#   how to create a bash ansible module:
#   * http://blog.trifork.com/2013/04/18/ansible-simple-module/
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.

DOCUMENTATION = '''
---
module: dpkg_dep
author: Tomas Pospisek
short_description: Create a pseudo package that has dependencies on given packages
description:
    - This module can be used to maintain dependencies for installed software. It creates
      a pseudo package with given parameters in /var/cache/apt/archives on the remote
      machine, that can be installed with the apt module.
version_added: "1.8"
options:
    name:
        description:
            - Name of the package. It is suggested to call the package something like
              "mysoftware-dependencies"
        required: true
    version:
        description:
            - version of the dependencies package
        required: true
    depends:
        description:
            - what you would put into the 'Depends:' field in a Debian package 'control' file
        required: true
notes:  []
'''
EXAMPLES = '''
- name: create foo dependencies
  dpkg_dep: name=foo-dependencies version=0.1 depends="dpkg (>=1.17.23)"
  register: foo
- name: install foo dependencies
  apt: deb=/var/cache/apt/archives/foo-dependencies_0.1_all.deb
  when: foo.changed
'''

import os
import re
import tempfile

# for debugging
import pdb

# import module snippets
from ansible.module_utils.basic import *

def need_to_update(module, package_name, new_version):

    rc, out, err = module.run_command("dpkg -s %s" % package_name)
  
    if rc == 0:    # package is installed
  
        version_line = re.findall("\nVersion:.*\n", out)[0]
        # remove 'Version:' and '\n' from string
        current_version = re.sub('\n', '', re.sub('\nVersion: ', '', version_line))
  
        rc, out, err = module.run_command(
          "dpkg --compare-versions '%s' gt '%s'" % (new_version, current_version))
  
        return ( rc == 0 )
    else:
        return True


def create_package(module, package_name, new_version, dependencies):

    build_dir = tempfile.mkdtemp( prefix='dpkg_dep.')
  
    package_name_full = "%s_%s_all" % (package_name, new_version)
    package_dir       = "%s/%s"     % (build_dir, package_name_full)

    os.mkdir( package_dir )
    os.mkdir( "%s/DEBIAN" % package_dir )
  
    control_new="%s/DEBIAN/control" % package_dir
    control = open(control_new, 'w')
    control.write(
"""Package: %s
Priority: optional
Section: dependencies
Installed-Size: 0
Maintainer: ansible
Architecture: all
Source: none
Version: %s
Depends: %s
Description: dependencies for %s
 This package was autogenerated by ansible
""" % (package_name, new_version, dependencies, package_name))

    control.close()
  
    rc, out, err = module.run_command( ["dpkg-deb", "-b", package_name_full], cwd=build_dir, check_rc=True )

    rc, out, err = module.run_command(
            ["mv", "%s.deb" % package_name_full, "/var/cache/apt/archives/"], cwd=build_dir, check_rc=True )

    # clean up
    mode = os.stat(build_dir).st_mode
    if S_ISDIR(mode):
        # build_dir only set if we did create the package...
        rc, out, err = module.run_command( ["rm", "-r", build_dir] )

def main():
    module = AnsibleModule(
        argument_spec = dict(
            name    = dict(required=True),
            depends = dict(required=True),
            version = dict(required=True),
        ),
        supports_check_mode=True
    )

    p = module.params

    package_name = p["name"]
    new_version  = p["version"]
    dependencies = p["depends"]

    changed = False

    if need_to_update(module, package_name, new_version):
        changed = True
        if not module.check_mode:
            create_package(module, package_name, new_version, dependencies)


    module.exit_json(changed=changed)

main()

